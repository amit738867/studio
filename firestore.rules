/**
 * @fileoverview Firestore Security Rules for CertifyAI.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for campaigns and their associated delivery statuses.
 * Certificate templates are publicly readable, but write access is unrestricted for prototyping.
 *
 * Data Structure:
 * - /certificateTemplates/{certificateTemplateId}: Stores publicly readable certificate templates.
 * - /users/{userId}/campaigns/{campaignId}: Stores campaigns owned by a specific user.
 * - /users/{userId}/campaigns/{campaignId}/deliveryStatuses/{deliveryStatusId}: Stores delivery statuses for a specific campaign.
 *
 * Key Security Decisions:
 * - Certificate Templates: For now, write access to certificate templates is open (`if true`).
 * - User Data Isolation: Campaigns and delivery statuses are strictly owned by the user identified in the path.
 * - Denormalization:  The `deliveryStatuses` are nested under the `campaigns` to make security rules easier to write and more performant since they do not need to `get()` the `campaigns` document to check permissions.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows anyone to read certificate templates. Write access is open for prototyping.
     * @path /certificateTemplates/{certificateTemplateId}
     * @allow get, list: if true
     * @allow create: if true // TODO: Add create authorization later
     * @allow update: if true // TODO: Add update authorization later
     * @allow delete: if true // TODO: Add delete authorization later
     * @deny create, update, delete: if false; //Required, to deny the operation by default, that are not explicitly allowed
     * @principle Public read, open writes for prototyping.
     */
    match /certificateTemplates/{certificateTemplateId} {
      allow get, list: if true;
      allow create: if true; // TODO: Add create authorization later
      allow update: if true; // TODO: Add update authorization later
      allow delete: if true; // TODO: Add delete authorization later
    }

    /**
     * @description Allows a user to manage their own campaigns.
     * @path /users/{userId}/campaigns/{campaignId}
     * @allow get, list: if isOwner(userId)
     * @allow create: if isOwner(userId)
     * @allow update: if isExistingOwner(userId)
     * @allow delete: if isExistingOwner(userId)
     * @deny get, list: if !isOwner(userId)
     * @deny create: if !isOwner(userId)
     * @deny update: if !isExistingOwner(userId)
     * @deny delete: if !isExistingOwner(userId)
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/campaigns/{campaignId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == campaignId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows a user to manage delivery statuses for their own campaigns.
     * @path /users/{userId}/campaigns/{campaignId}/deliveryStatuses/{deliveryStatusId}
     * @allow get, list: if isOwner(userId)
     * @allow create: if isOwner(userId)
     * @allow update: if isExistingOwner(userId)
     * @allow delete: if isExistingOwner(userId)
     * @deny get, list: if !isOwner(userId)
     * @deny create: if !isOwner(userId)
     * @deny update: if !isExistingOwner(userId)
     * @deny delete: if !isExistingOwner(userId)
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/campaigns/{campaignId}/deliveryStatuses/{deliveryStatusId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }
  }
}